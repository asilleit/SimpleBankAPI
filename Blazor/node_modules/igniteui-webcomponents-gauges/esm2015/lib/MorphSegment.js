/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-webcomponents-core";
import { List$1 } from "igniteui-webcomponents-core";
import { GeometryUtil } from "igniteui-webcomponents-core";
import { PolyLineSegment } from "igniteui-webcomponents-core";
import { ArcSegment } from "igniteui-webcomponents-core";
import { Size } from "igniteui-webcomponents-core";
import { InterpolationUtil } from "igniteui-webcomponents-core";
/**
 * @hidden
 */
export let MorphSegment = /*@__PURE__*/ (() => {
    class MorphSegment extends Base {
        constructor() {
            super();
            this.f = null;
            this.g = null;
            this.b = false;
            this.h = 0;
            this.e = false;
            this.a = false;
            this.d = false;
            this.c = false;
            this.f = new List$1(Point_$type, 0);
            this.g = new List$1(Point_$type, 0);
        }
        i(a) {
            this.g.clear();
            let b = 20;
            if (this.b) {
                let c;
                let d;
                let e;
                if (this.f.count == 0) {
                    d = { $type: Point_$type, x: 0, y: 0 };
                    e = { $type: Point_$type, x: 0, y: 0 };
                }
                else {
                    d = this.f._inner[0];
                    e = this.f._inner[1];
                }
                let f = GeometryUtil.n(d, e, this.h, !this.c, this.d);
                let g = GeometryUtil.f(f, d);
                let h = GeometryUtil.f(f, e);
                while (this.c && h < g) {
                    h += Math.PI * 2;
                }
                while (!this.c && h > g) {
                    h -= Math.PI * 2;
                }
                let i = 0;
                for (let j = 0; j < b; j++) {
                    c = j / b;
                    if (this.c) {
                        i = g + (h - g) * c;
                    }
                    else {
                        i = g - (g - h) * c;
                    }
                    this.g.add({ $type: Point_$type, x: f.x + Math.cos(i) * this.h, y: f.y + Math.sin(i) * this.h });
                }
            }
            else {
                let k;
                let l;
                let m;
                if (this.f.count == 0) {
                    l = { $type: Point_$type, x: 0, y: 0 };
                    m = { $type: Point_$type, x: 0, y: 0 };
                }
                else {
                    l = this.f._inner[0];
                    m = this.f._inner[1];
                }
                let n = l.x;
                let o = l.y;
                let p = m.x;
                let q = m.y;
                for (let r = 0; r < b; r++) {
                    k = r / b;
                    this.g.add({ $type: Point_$type, x: n + (p - n) * k, y: o + (q - o) * k });
                }
            }
            this.a = true;
        }
        l(a, b, c, d, e) {
            let f = this;
            let g = null;
            let h = f.f;
            let i = h.count;
            if (i == 0) {
                return a;
            }
            if (b._segments.count == 0) {
                let j = h._inner[0];
                b._startPoint = { $type: Point_$type, x: d + c * j.x, y: e + c * j.y };
            }
            if (f.b) {
                if (i > 1) {
                    let k = new ArcSegment();
                    g = k;
                    let l = h._inner[1];
                    k.e = { $type: Point_$type, x: d + c * l.x, y: e + c * l.y };
                    k.b = f.d;
                    k.d = f.c ? 1 : 0;
                    k.f = new Size(1, f.h * c, f.h * c);
                    a = k.e;
                }
            }
            else {
                let m = new PolyLineSegment();
                g = m;
                if (i > 1) {
                    let n;
                    let o = m._points;
                    for (let p = 1; p < i; p++) {
                        n = h._inner[p];
                        o.add({ $type: Point_$type, x: d + c * n.x, y: e + c * n.y });
                    }
                    a = m._points._inner[m._points.count - 1];
                }
            }
            b._segments.add(g);
            return a;
        }
        j(a, b, c) {
            let d = this;
            let e = d;
            let f = b.f;
            let g = false;
            let h = c.f;
            let i = false;
            if (f.count == 0 && h.count == 0) {
                return;
            }
            e.b = false;
            e.e = false;
            e.a = false;
            e.d = false;
            e.c = false;
            if (b.e) {
                g = true;
            }
            if (c.e) {
                i = true;
            }
            if (b.b != c.b || b.e || c.e || b.d != c.d || b.c != c.c) {
                g = true;
                i = true;
                e.e = true;
            }
            if (g && !b.e) {
                if (!b.a) {
                    b.i(c.h);
                }
                f = b.g;
            }
            if (i && !c.e) {
                if (!c.a) {
                    c.i(b.h);
                }
                h = c.g;
            }
            if (b.e) {
                f = b.g;
            }
            if (c.e) {
                h = c.g;
            }
            e.g.clear();
            if (b.b && c.b) {
                e.b = true;
            }
            InterpolationUtil.b(e.f, a, f, h);
            if (e.e) {
                let j;
                let k = e.f.count;
                for (let l = 0; l < k; l++) {
                    j = e.f._inner[l];
                    e.g.add({ $type: Point_$type, x: j.x, y: j.y });
                }
                e.a = true;
            }
            if (b.d == c.d) {
                e.d = c.d;
            }
            if (b.c == c.c) {
                e.c = c.c;
            }
            if (e.b) {
                e.h = b.h + (c.h - b.h) * a;
            }
        }
        k() {
            this.f.clear();
            this.g.clear();
            this.e = false;
            this.a = false;
            this.b = false;
        }
    }
    MorphSegment.$t = /*@__PURE__*/ markType(MorphSegment, 'MorphSegment');
    return MorphSegment;
})();

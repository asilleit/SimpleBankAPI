/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import * as tslib_1 from "tslib";
import { Base, Point_$type, markType } from "igniteui-webcomponents-core";
import { List$1 } from "igniteui-webcomponents-core";
import { GeometryUtil } from "igniteui-webcomponents-core";
import { PolyLineSegment } from "igniteui-webcomponents-core";
import { ArcSegment } from "igniteui-webcomponents-core";
import { Size } from "igniteui-webcomponents-core";
import { InterpolationUtil } from "igniteui-webcomponents-core";
/**
 * @hidden
 */
var MorphSegment = /** @class */ /*@__PURE__*/ (function (_super) {
    tslib_1.__extends(MorphSegment, _super);
    function MorphSegment() {
        var _this = _super.call(this) || this;
        _this.f = null;
        _this.g = null;
        _this.b = false;
        _this.h = 0;
        _this.e = false;
        _this.a = false;
        _this.d = false;
        _this.c = false;
        _this.f = new List$1(Point_$type, 0);
        _this.g = new List$1(Point_$type, 0);
        return _this;
    }
    MorphSegment.prototype.i = function (a) {
        this.g.clear();
        var b = 20;
        if (this.b) {
            var c = void 0;
            var d = void 0;
            var e = void 0;
            if (this.f.count == 0) {
                d = { $type: Point_$type, x: 0, y: 0 };
                e = { $type: Point_$type, x: 0, y: 0 };
            }
            else {
                d = this.f._inner[0];
                e = this.f._inner[1];
            }
            var f = GeometryUtil.n(d, e, this.h, !this.c, this.d);
            var g = GeometryUtil.f(f, d);
            var h = GeometryUtil.f(f, e);
            while (this.c && h < g) {
                h += Math.PI * 2;
            }
            while (!this.c && h > g) {
                h -= Math.PI * 2;
            }
            var i = 0;
            for (var j = 0; j < b; j++) {
                c = j / b;
                if (this.c) {
                    i = g + (h - g) * c;
                }
                else {
                    i = g - (g - h) * c;
                }
                this.g.add({ $type: Point_$type, x: f.x + Math.cos(i) * this.h, y: f.y + Math.sin(i) * this.h });
            }
        }
        else {
            var k = void 0;
            var l = void 0;
            var m = void 0;
            if (this.f.count == 0) {
                l = { $type: Point_$type, x: 0, y: 0 };
                m = { $type: Point_$type, x: 0, y: 0 };
            }
            else {
                l = this.f._inner[0];
                m = this.f._inner[1];
            }
            var n = l.x;
            var o = l.y;
            var p = m.x;
            var q = m.y;
            for (var r = 0; r < b; r++) {
                k = r / b;
                this.g.add({ $type: Point_$type, x: n + (p - n) * k, y: o + (q - o) * k });
            }
        }
        this.a = true;
    };
    MorphSegment.prototype.l = function (a, b, c, d, e) {
        var f = this;
        var g = null;
        var h = f.f;
        var i = h.count;
        if (i == 0) {
            return a;
        }
        if (b._segments.count == 0) {
            var j = h._inner[0];
            b._startPoint = { $type: Point_$type, x: d + c * j.x, y: e + c * j.y };
        }
        if (f.b) {
            if (i > 1) {
                var k = new ArcSegment();
                g = k;
                var l = h._inner[1];
                k.e = { $type: Point_$type, x: d + c * l.x, y: e + c * l.y };
                k.b = f.d;
                k.d = f.c ? 1 : 0;
                k.f = new Size(1, f.h * c, f.h * c);
                a = k.e;
            }
        }
        else {
            var m = new PolyLineSegment();
            g = m;
            if (i > 1) {
                var n = void 0;
                var o = m._points;
                for (var p = 1; p < i; p++) {
                    n = h._inner[p];
                    o.add({ $type: Point_$type, x: d + c * n.x, y: e + c * n.y });
                }
                a = m._points._inner[m._points.count - 1];
            }
        }
        b._segments.add(g);
        return a;
    };
    MorphSegment.prototype.j = function (a, b, c) {
        var d = this;
        var e = d;
        var f = b.f;
        var g = false;
        var h = c.f;
        var i = false;
        if (f.count == 0 && h.count == 0) {
            return;
        }
        e.b = false;
        e.e = false;
        e.a = false;
        e.d = false;
        e.c = false;
        if (b.e) {
            g = true;
        }
        if (c.e) {
            i = true;
        }
        if (b.b != c.b || b.e || c.e || b.d != c.d || b.c != c.c) {
            g = true;
            i = true;
            e.e = true;
        }
        if (g && !b.e) {
            if (!b.a) {
                b.i(c.h);
            }
            f = b.g;
        }
        if (i && !c.e) {
            if (!c.a) {
                c.i(b.h);
            }
            h = c.g;
        }
        if (b.e) {
            f = b.g;
        }
        if (c.e) {
            h = c.g;
        }
        e.g.clear();
        if (b.b && c.b) {
            e.b = true;
        }
        InterpolationUtil.b(e.f, a, f, h);
        if (e.e) {
            var j = void 0;
            var k = e.f.count;
            for (var l = 0; l < k; l++) {
                j = e.f._inner[l];
                e.g.add({ $type: Point_$type, x: j.x, y: j.y });
            }
            e.a = true;
        }
        if (b.d == c.d) {
            e.d = c.d;
        }
        if (b.c == c.c) {
            e.c = c.c;
        }
        if (e.b) {
            e.h = b.h + (c.h - b.h) * a;
        }
    };
    MorphSegment.prototype.k = function () {
        this.f.clear();
        this.g.clear();
        this.e = false;
        this.a = false;
        this.b = false;
    };
    MorphSegment.$t = markType(MorphSegment, 'MorphSegment');
    return MorphSegment;
}(Base));
export { MorphSegment };

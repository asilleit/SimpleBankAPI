import { ISupportsDataChangeNotifications } from "./ISupportsDataChangeNotifications";
import { IDataSourceSupportsCount } from "./IDataSourceSupportsCount";
import { IDataSourceSchema } from "./IDataSourceSchema";
import { IDataSourceExecutionContext } from "./IDataSourceExecutionContext";
import { IDataSourceDataProviderUpdateNotifier } from "./IDataSourceDataProviderUpdateNotifier";
import { SortDescriptionCollection } from "./SortDescriptionCollection";
import { DataSourceSummaryScope } from "./DataSourceSummaryScope";
import { Base, Type, IList$1, PropertyChangedEventArgs } from "./type";
import { DataSourceDataProviderSchemaChangedEventArgs } from "./DataSourceDataProviderSchemaChangedEventArgs";
import { DataSourceSchemaPropertyType } from "./DataSourceSchemaPropertyType";
import { SyncableObservableCollection$1 } from "./SyncableObservableCollection$1";
import { NotifyCollectionChangedEventArgs } from "./NotifyCollectionChangedEventArgs";
import { IDataSourceSupportsIndexedAccess } from "./IDataSourceSupportsIndexedAccess";
import { IDataSourceUpdateNotifier } from "./IDataSourceUpdateNotifier";
import { DataSourceSectionHeaderDisplayMode } from "./DataSourceSectionHeaderDisplayMode";
import { DataSourceSchemaChangedEventArgs } from "./DataSourceSchemaChangedEventArgs";
import { DataSourceRowExpansionChangedEventArgs } from "./DataSourceRowExpansionChangedEventArgs";
import { DataSourceRowType } from "./DataSourceRowType";
import { ISummaryResult } from "./ISummaryResult";
import { DataSourceSummaryOperand } from "./DataSourceSummaryOperand";
import { IEditableDataSource } from "./IEditableDataSource";
import { TransactionService } from "./TransactionService";
import { IExternalDataSource } from "./IExternalDataSource";
import { TransactionEvent } from "./TransactionEvent";
import { DataSourceSpecialRow } from "./DataSourceSpecialRow";
import { DataSourceAggregatedResult } from "./DataSourceAggregatedResult";
import { DataSourceDataCommittedEventArgs } from "./DataSourceDataCommittedEventArgs";
/**
 * @hidden
 */
export interface IDataSourceDataProvider extends ISupportsDataChangeNotifications, IDataSourceSupportsCount {
    getItemValue(a: any, b: string): any;
    setItemValue(a: any, b: string, c: any): void;
    removeItem(a: any): void;
    addItem(a: any): void;
    schemaChanged: (sender: any, args: DataSourceDataProviderSchemaChangedEventArgs) => void;
    readonly actualSchema: IDataSourceSchema;
    executionContext: IDataSourceExecutionContext;
    updateNotifier: IDataSourceDataProviderUpdateNotifier;
    queueAutoRefresh(): void;
    deferAutoRefresh: boolean;
    flushAutoRefresh(): void;
    refresh(): void;
    readonly isSortingSupported: boolean;
    readonly isGroupingSupported: boolean;
    readonly sortDescriptions: SortDescriptionCollection;
    readonly groupDescriptions: SortDescriptionCollection;
    readonly summaryDescriptions: SummaryDescriptionCollection;
    summaryScope: DataSourceSummaryScope;
    readonly isFilteringSupported: boolean;
    readonly filterExpressions: FilterExpressionCollection;
    propertiesRequested: string[];
    readonly notifyUsingSourceIndexes: boolean;
    indexOfItem(a: any): number;
    indexOfKey(a: any[]): number;
    readonly isItemIndexLookupSupported: boolean;
    readonly isKeyIndexLookupSupported: boolean;
    resolveSchemaPropertyType(a: string): DataSourceSchemaPropertyType;
}
/**
 * @hidden
 */
export declare let IDataSourceDataProvider_$type: Type;
/**
 * @hidden
 */
export interface IFilterExpression {
    evaluate(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): any;
    readonly isPropertyReference: boolean;
    readonly isOperation: boolean;
    readonly isFunction: boolean;
    readonly isLiteral: boolean;
    readonly isNull: boolean;
    readonly isWrapper: boolean;
    match(a: any, b: IDataSourceDataProvider, c: IDataSourceSchema): boolean;
    readonly precedence: number;
    readonly isAutoGenerated: boolean;
    markAutoGenerated(): void;
}
/**
 * @hidden
 */
export declare let IFilterExpression_$type: Type;
/**
 * @hidden
 */
export declare class FilterExpressionCollection extends Base {
    static $t: Type;
    private a;
    syncTarget: FilterExpressionCollection;
    private f;
    shouldDetachOnTargetChange: boolean;
    constructor();
    add(a: IFilterExpression): boolean;
    insert(a: number, b: IFilterExpression): void;
    clear(): void;
    get(a: number): IFilterExpression;
    indexOf(a: IFilterExpression): number;
    remove(a: IFilterExpression): boolean;
    removeAt(a: number): IFilterExpression;
    set(a: number, b: IFilterExpression): IFilterExpression;
    size(): number;
    onChanged: () => void;
    n(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    q(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    readonly k: IList$1<IFilterExpression>;
}
/**
 * @hidden
 */
export interface IDataSource extends ISupportsDataChangeNotifications, IDataSourceSupportsIndexedAccess {
    schemaChanged: (sender: any, args: DataSourceSchemaChangedEventArgs) => void;
    rowExpansionChanged: (sender: any, args: DataSourceRowExpansionChangedEventArgs) => void;
    isPlaceholderItem(a: number): boolean;
    getItemPropertyAtIndex(a: number, b: string): any;
    getItemProperty(a: any, b: string): any;
    updateNotifier: IDataSourceUpdateNotifier;
    readonly executionContext: IDataSourceExecutionContext;
    readonly actualSchema: IDataSourceSchema;
    firstVisibleIndexRequested: number;
    lastVisibleIndexRequested: number;
    readonly isVirtual: boolean;
    readonly isSortingSupported: boolean;
    readonly sortDescriptions: SortDescriptionCollection;
    readonly groupDescriptions: SortDescriptionCollection;
    readonly summaryDescriptions: SummaryDescriptionCollection;
    summaryScope: DataSourceSummaryScope;
    readonly isFilteringSupported: boolean;
    readonly notifyUsingSourceIndexes: boolean;
    readonly filterExpressions: FilterExpressionCollection;
    queueAutoRefresh(): void;
    deferAutoRefresh: boolean;
    flushAutoRefresh(): void;
    refresh(): void;
    primaryKey: string[];
    readonly actualPrimaryKey: string[];
    propertiesRequested: string[];
    indexOfItem(a: any): number;
    indexOfKey(a: any[]): number;
    readonly isItemIndexLookupSupported: boolean;
    readonly isKeyIndexLookupSupported: boolean;
    readonly isGroupingSupported: boolean;
    sectionHeaderDisplayMode: DataSourceSectionHeaderDisplayMode;
    isSectionCollapsable: boolean;
    isSectionExpandedDefault: boolean;
    includeSummaryRowsInSection: boolean;
    isSectionSummaryRowsAtBottom: boolean;
    isSectionHeaderNormalRow: boolean;
    isSectionContentVisible: boolean;
    getRowType(a: number): DataSourceRowType;
    getMainValuePath(a: DataSourceRowType): string;
    getStickyRows(): number[];
    getStickyRowsInRange(a: number, b: number): number[];
    getStickyRowPriority(a: number): number;
    isExclusivelySticky(a: number): boolean;
    isRowSpanning(a: DataSourceRowType): boolean;
    pinRow(a: any[]): void;
    unpinRow(a: any[]): void;
    clearPinnedRows(): void;
    isRowPinned(a: number): boolean;
    shouldEmitSectionHeaders: boolean;
    shouldEmitSectionFooters: boolean;
    shouldEmitShiftedRows: boolean;
    shouldEmitSummaryRows: boolean;
    resolveSchemaPropertyType(a: string): DataSourceSchemaPropertyType;
    setIsRowExpandedAtIndex(a: number, b: boolean): void;
    getIsRowExpandedAtIndex(a: number): boolean;
    getRowLevel(a: number): number;
    getRootSummaryRowCount(): number;
    getRootSummaryResults(): ISummaryResult[];
    getSectionSummaryResults(a: number): ISummaryResult[][];
    clone(): IDataSource;
}
/**
 * @hidden
 */
export declare let IDataSource_$type: Type;
/**
 * @hidden
 */
export declare abstract class SummaryCalculator extends Base {
    static $t: Type;
    private _propertyName;
    propertyName: string;
    private _propertyType;
    propertyType: DataSourceSchemaPropertyType;
    private _dataSource;
    dataSource: IDataSource;
    abstract readonly displayName: string;
    private _isSummaryDirty;
    isSummaryDirty: boolean;
    private b;
    protected get_operand(): DataSourceSummaryOperand;
    readonly operand: DataSourceSummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
    protected i(a: any): number;
    protected j(a: any): number;
    protected k(a: number): any;
}
/**
 * @hidden
 */
export declare class SumSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): DataSourceSummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
}
/**
 * @hidden
 */
export declare class CountSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): DataSourceSummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
}
/**
 * @hidden
 */
export declare class AverageSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    private q;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): DataSourceSummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
}
/**
 * @hidden
 */
export declare class MaxSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): DataSourceSummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
    private q;
}
/**
 * @hidden
 */
export declare class MinSummaryCalculator extends SummaryCalculator {
    static $t: Type;
    private p;
    protected get_displayName(): string;
    readonly displayName: string;
    protected get_operand(): DataSourceSummaryOperand;
    beginCalculation(a: IDataSource, b: string): void;
    endCalculation(): ISummaryResult;
    aggregate(a: any): void;
    itemAdded(a: any, b: ISummaryResult, c: number): ISummaryResult;
    itemRemoved(a: any, b: ISummaryResult, c: number): ISummaryResult;
    private q;
}
/**
 * @hidden
 */
export declare class SummaryDescription extends Base {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, b: string, c: DataSourceSummaryOperand);
    constructor(a: number, ..._rest: any[]);
    private k;
    propertyName: string;
    private a;
    operand: DataSourceSummaryOperand;
    private _alias;
    alias: string;
    private d;
    calculator: SummaryCalculator;
    equals(a: any): boolean;
    getHashCode(): number;
    n(): void;
    provideCalculator: (sender: any, args: ProvideCalculatorEventArgs) => void;
    private g;
    f(): SummaryCalculator;
}
/**
 * @hidden
 */
export declare class SummaryDescriptionCollection extends Base {
    static $t: Type;
    g(): SyncableObservableCollection$1<SummaryDescription>;
    private d;
    syncTarget: SummaryDescriptionCollection;
    private f;
    constructor();
    add(a: SummaryDescription): boolean;
    insert(a: number, b: SummaryDescription): void;
    clear(): void;
    get(a: number): SummaryDescription;
    indexOf(a: SummaryDescription): number;
    remove(a: SummaryDescription): boolean;
    removeAt(a: number): SummaryDescription;
    set(a: number, b: SummaryDescription): SummaryDescription;
    size(): number;
    n(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    q(a: (sender: any, e: NotifyCollectionChangedEventArgs) => void): void;
    onChanged: () => void;
    readonly k: IList$1<SummaryDescription>;
}
/**
 * @hidden
 */
export declare class ProvideCalculatorEventArgs extends Base {
    static $t: Type;
    a: SummaryCalculator;
}
/**
 * @hidden
 */
export declare abstract class BaseDataSource extends Base implements IDataSource, IEditableDataSource {
    static $t: Type;
    constructor();
    protected u: TransactionService;
    private cp;
    protected co(a: TransactionEvent, b: any): void;
    protected aq(): boolean;
    private bz;
    private clone1;
    private _isReadOnly;
    isReadOnly: boolean;
    private z;
    protected get_isBatchingEnabled(): boolean;
    protected set_isBatchingEnabled(a: boolean): void;
    isBatchingEnabled: boolean;
    readonly canUndo: boolean;
    readonly canRedo: boolean;
    readonly canCommit: boolean;
    updatePropertyAtKey(a: any[], b: string, c: any, d?: boolean): number;
    removeItemByKey(a: any[]): void;
    removeItem(a: any): void;
    addItem(a: any): void;
    acceptPendingTransaction(a: number): void;
    rejectPendingTransaction(a: number): void;
    commitEdits(a: boolean): number;
    cancelEdits(): void;
    acceptPendingCommit(a: number): void;
    rejectPendingCommit(a: number): void;
    undo(): void;
    redo(): void;
    hasEdit(a: any[], b: string): boolean;
    hasDelete(a: any[]): boolean;
    hasAdd(a: any): boolean;
    getAggregatedChanges(a: number): DataSourceAggregatedResult[];
    isPendingTransaction(a: number): boolean;
    isPendingCommit(a: number): boolean;
    setTransactionError(a: number, b: string): void;
    getTransactionErrorByKey(a: any[], b: string): string;
    getTransactionErrorByID(a: number): string;
    getTransactionID(a: any[], b: string): number;
    private f;
    dataCommitted: (sender: any, e: DataSourceDataCommittedEventArgs) => void;
    protected b0(a: number, b: DataSourceAggregatedResult[]): void;
    static ba(a: string): string;
    private ct;
    private bx;
    private cu;
    private bv;
    protected onSortDescriptionsChanged(a: NotifyCollectionChangedEventArgs): void;
    protected onGroupDescriptionsChanged(a: NotifyCollectionChangedEventArgs): void;
    protected onSummaryDescriptionsChanged(a: NotifyCollectionChangedEventArgs): void;
    protected ap: boolean;
    protected onFilterExpressionsChanged(a: NotifyCollectionChangedEventArgs): void;
    onRowExpansionChanged(a: number, b: boolean, c: boolean): void;
    isPlaceholderItem(a: number): boolean;
    az: any;
    private _externalDataSource;
    externalDataSource: IExternalDataSource;
    private s;
    private r;
    private i;
    private t;
    private j;
    protected abstract readonly actualBaseDataProvider: IDataSourceDataProvider;
    private o;
    actualSchema: IDataSourceSchema;
    private at;
    actualCount: number;
    private au;
    firstVisibleIndexRequested: number;
    private av;
    lastVisibleIndexRequested: number;
    private p;
    updateNotifier: IDataSourceUpdateNotifier;
    getItemAtIndex(a: number): any;
    getItemFromKey(a: any[]): any;
    getItemProperty(a: any, b: string): any;
    getSpecialRowItemValue(a: DataSourceSpecialRow, b: string): any;
    protected a1(a: any, b: string): any;
    protected an(a: any, b: string): boolean;
    getItemPropertyAtIndex(a: number, b: string): any;
    protected get_fullSectionInformationWillForceLoad(): boolean;
    readonly fullSectionInformationWillForceLoad: boolean;
    propertyChanged: (sender: any, e: PropertyChangedEventArgs) => void;
    protected onPropertyUpdated(a: string, b: any, c: any): void;
    protected propertyUpdatedOverride(a: string, b: any, c: any): void;
    protected onActualPrimaryKeyChanged(a: string[], b: string[]): void;
    protected onActualPrimaryKeyChangedOverrride(a: string[], b: string[]): void;
    protected get_isVirtual(): boolean;
    readonly isVirtual: boolean;
    private l;
    protected readonly dataProviderUpdateNotifier: IDataSourceDataProviderUpdateNotifier;
    protected onActualDataProviderChanged(a: any, b: any): void;
    protected onRequestedVisibleRangeChanged(): void;
    private n;
    executionContext: IDataSourceExecutionContext;
    schemaChanged: (sender: any, args: DataSourceSchemaChangedEventArgs) => void;
    rowExpansionChanged: (sender: any, args: DataSourceRowExpansionChangedEventArgs) => void;
    protected canInitialize(): boolean;
    private aa;
    protected readonly isInitializing: boolean;
    protected get_isSortingSupported(): boolean;
    readonly isSortingSupported: boolean;
    protected get_isFilteringSupported(): boolean;
    readonly isFilteringSupported: boolean;
    readonly sortDescriptions: SortDescriptionCollection;
    readonly groupDescriptions: SortDescriptionCollection;
    readonly filterExpressions: FilterExpressionCollection;
    readonly summaryDescriptions: SummaryDescriptionCollection;
    private h;
    summaryScope: DataSourceSummaryScope;
    private x;
    deferAutoRefresh: boolean;
    private b;
    primaryKey: string[];
    private a;
    actualPrimaryKey: string[];
    private c;
    propertiesRequested: string[];
    private ag;
    notifyUsingSourceIndexes: boolean;
    protected get_isItemIndexLookupSupported(): boolean;
    readonly isItemIndexLookupSupported: boolean;
    protected get_isKeyIndexLookupSupported(): boolean;
    readonly isKeyIndexLookupSupported: boolean;
    protected initializeOverride(): void;
    private ah;
    protected resolveFullCount(a: number): number;
    private br;
    private b1;
    onSetItem(a: number, b: any, c: any): void;
    onBroadcastSetItem(a: number, b: any, c: any): void;
    onSetItemOverride(a: number, b: any, c: any): void;
    onClearItems(): void;
    onBroadcastClearItems(): void;
    onClearItemsOverride(): void;
    onInsertItem(a: number, b: any): void;
    onBroadcastInsertItem(a: number, b: any): void;
    onInsertItemOverride(a: number, b: any): void;
    onRemoveItem(a: number, b: any): void;
    onBroadcastRemoveItem(a: number, b: any): void;
    onRemoveItemOverride(a: number, b: any): void;
    notifySetItem(a: number, b: any, c: any): void;
    notifyClearItems(): void;
    notifyInsertItem(a: number, b: any): void;
    notifyRemoveItem(a: number, b: any): void;
    v: boolean;
    queueAutoRefresh(): void;
    bt(): void;
    cr(): void;
    protected refreshInternalOverride(): void;
    flushAutoRefresh(): void;
    refresh(): void;
    indexOfItem(a: any): number;
    indexOfKey(a: any[]): number;
    protected getPrimaryKeyValue(a: any, b: any[]): void;
    getRowType(a: number): DataSourceRowType;
    getMainValuePath(a: DataSourceRowType): string;
    getStickyRows(): number[];
    getStickyRowsInRange(a: number, b: number): number[];
    isRowSpanning(a: DataSourceRowType): boolean;
    getStickyRowPriority(a: number): number;
    isExclusivelySticky(a: number): boolean;
    pinRow(a: any[]): void;
    unpinRow(a: any[]): void;
    clearPinnedRows(): void;
    isRowPinned(a: number): boolean;
    protected get_isGroupingSupported(): boolean;
    readonly isGroupingSupported: boolean;
    private g;
    protected get_sectionHeaderDisplayMode(): DataSourceSectionHeaderDisplayMode;
    protected set_sectionHeaderDisplayMode(a: DataSourceSectionHeaderDisplayMode): void;
    sectionHeaderDisplayMode: DataSourceSectionHeaderDisplayMode;
    private ab;
    protected get_isSectionCollapsable(): boolean;
    protected set_isSectionCollapsable(a: boolean): void;
    isSectionCollapsable: boolean;
    private ad;
    protected get_isSectionExpandedDefault(): boolean;
    protected set_isSectionExpandedDefault(a: boolean): void;
    isSectionExpandedDefault: boolean;
    private y;
    protected get_includeSummaryRowsInSection(): boolean;
    protected set_includeSummaryRowsInSection(a: boolean): void;
    includeSummaryRowsInSection: boolean;
    private af;
    protected get_isSectionSummaryRowsAtBottom(): boolean;
    protected set_isSectionSummaryRowsAtBottom(a: boolean): void;
    isSectionSummaryRowsAtBottom: boolean;
    private ae;
    protected get_isSectionHeaderNormalRow(): boolean;
    protected set_isSectionHeaderNormalRow(a: boolean): void;
    isSectionHeaderNormalRow: boolean;
    private ac;
    protected get_isSectionContentVisible(): boolean;
    protected set_isSectionContentVisible(a: boolean): void;
    isSectionContentVisible: boolean;
    private aj;
    shouldEmitSectionHeaders: boolean;
    private ai;
    shouldEmitSectionFooters: boolean;
    private ak;
    shouldEmitShiftedRows: boolean;
    private al;
    shouldEmitSummaryRows: boolean;
    protected w: boolean;
    protected d: boolean[];
    protected ensureComparables(a: IDataSourceSchema): void;
    protected e(a: IDataSourceSchema, b: any): boolean[];
    resolveSchemaPropertyType(a: string): DataSourceSchemaPropertyType;
    setIsRowExpandedAtIndex(a: number, b: boolean): void;
    getIsRowExpandedAtIndex(a: number): boolean;
    getRowLevel(a: number): number;
    getRootSummaryRowCount(): number;
    getRootSummaryResults(): ISummaryResult[];
    getSectionSummaryResults(a: number): ISummaryResult[][];
    clone(): IDataSource;
    cloneProperties(a: IDataSource): void;
    getRowCount(): number;
}
/**
 * @hidden
 */
export declare class DefaultDataSourceDataProviderUpdateNotifier extends Base implements IDataSourceDataProviderUpdateNotifier {
    static $t: Type;
    private a;
    constructor(a: BaseDataSource);
    notifySetItem(a: number, b: any, c: any): void;
    notifyClearItems(): void;
    notifyInsertItem(a: number, b: any): void;
    notifyRemoveItem(a: number, b: any): void;
}
